# 复杂 data 的处理方式

　　我们知道，在模板中可以直接通过**插值语法**显示一些 **data 中的数据**。

　　但是在某些情况，我们可能需要对**数据进行一些转化后**再显示，或者需要**将多个数据结合起来**进行显示；

* 比如我们需要**对多个 data 数据进行运算**、**三元运算符来决定结果**、**数据****进行某种转化**后显示；

* 在模板中使用**表达式**，可以非常方便的实现，但是设计它们的初衷是用于**简单的运算**；

* 在模板中放入太多的逻辑会让**模板过重和难以维护**；

* 并且如果多个地方都使用到，那么会有大量重复的代码；

　　我们有没有什么方法可以将逻辑抽离出去呢？

* 可以，其中一种方式就是将逻辑抽取到一个 **method** 中，放到 methods 的 options 中；

* 但是，这种做法有一个直观的弊端，就是所有的 data 使用过程都会变成了一个**方法的调用**；

* 另外一种方式就是使用计算属性 **computed**；

　　

# 计算属性 computed

## 认识计算属性 computed

　　什么是计算属性呢？

* 官方并没有给出直接的概念解释；

* 而是说：对于任何包含响应式数据的复杂逻辑，你都应该使用**计算属性**；

* **计算属性**将被混入到组件实例中。所有 getter 和 setter 的 this 上下文自动地绑定为组件实例；

　　计算属性的用法：

* 选项：computed

* 类型：{ [key: string]: Function | { get: Function, set: Function } }

　　

### 案例实现思路

　　我们来看三个案例：

　　案例一：我们有两个变量：firstName 和 lastName，希望它们拼接之后在界面上显示；

　　案例二：我们有一个分数：score

* 当 score 大于 60 的时候，在界面上显示及格；

* 当 score 小于 60 的时候，在界面上显示不及格；

　　案例三：我们有一个变量 message，记录一段文字：比如 Hello World

* 某些情况下我们是直接显示这段文字；

* 某些情况下我们需要对这段文字进行反转；

　　我们可以有三种实现思路：

* 思路一：在模板语法中直接使用表达式；

* 思路二：使用 method 对逻辑进行抽取；

* 思路三：使用计算属性 computed；

　　

#### 实现思路一：模板语法

　　思路一的实现：模板语法

* 缺点一：模板中存在大量的复杂逻辑，不便于维护（模板中表达式的初衷是用于简单的计算）；

* 缺点二：当有多次一样的逻辑时，存在重复的代码；

* 缺点三：多次使用的时候，很多运算也需要多次执行，没有缓存；

　　![image.png](image-20211129135437-bo14mvj.png)

　　

#### 实现思路二：method 实现

　　思路二的实现：method 实现

* 缺点一：我们事实上先显示的是一个结果，但是都变成了一种方法的调用；

* 缺点二：多次使用方法的时候，没有缓存，也需要多次计算；

　　![image.png](image-20211129135447-07wkdr1.png)![image.png](image-20211129135454-njsng3m.png)

　　

#### 思路三的实现：computed 实现

　　思路三的实现：computed 实现

* 注意：计算属性看起来像是一个函数，但是我们在使用的时候不需要加()，这个后面讲 setter 和 getter 时会讲到；

* 我们会发现无论是直观上，还是效果上计算属性都是更好的选择；

* 并且计算属性是有缓存的；

　　![image.png](image-20211129135512-bi78qbu.png)![image.png](image-20211129135522-llave1n.png)

　　

## 计算属性 vs methods

　　在上面的实现思路中，我们会发现计算属性和 methods 的实现看起来是差别是不大的，而且我们多次提到计算属性**有缓存的**。

　　接下来我们来看一下同一个计算多次使用，计算属性和 methods 的差异：

　　![image.png](image-20211115100736-cfed4kg.png)

　　

## 计算属性的缓存

　　这是什么原因呢？

* 这是因为计算属性会基于它们的**依赖关系进行缓存**；

* 在**数据不发生变化**时，计算属性是**不需要重新计算**的；

* 但是如果**依赖的数据发生变化**，在使用时，计算属性依然**会重新进行计算**；

　　![image.png](image-20211129135540-m4jvljh.png)

　　

## 计算属性的 setter 和 getter

　　计算属性在大多数情况下，只需要一个 **getter 方法**即可，所以我们会将计算属性直接**写成一个函数**。

　　但是，如果我们确实想**设置计算属性的值**呢？

* 这个时候我们也可以给计算属性设置一个 **setter 的方法**；

　　![image.png](image-20211129135549-r9j9tg0.png)

　　

## 源码如何对 setter 和 getter 处理呢？

　　你可能觉得很奇怪，Vue 内部是如何对我们传入的是一个 getter，还是说是一个包含 setter 和 getter 的对象进行处

　　理的呢？

* 事实上非常的简单，Vue 源码内部只是做了一个逻辑判断而已；

　　![image.png](image-20211129135559-bkl7hij.png)

　　

　　

# 侦听器 watch

## 认识侦听器 watch

　　什么是侦听器呢？

* 开发中我们在 data 返回的对象中定义了数据，这个数据通过**插值语法等方式绑定到 template** 中；

* 当数据变化时，template 会自动进行更新来显示最新的数据；

* 但是在某些情况下，我们希望在**代码逻辑**中监听某个数据的变化，这个时候就需要用**侦听器 watch** 来完成了

　　侦听器的用法如下：

* 选项：watch

* 类型：{ [key: string]: string | Function | Object | Array}

　　

### 侦听器案例

　　举个栗子（例子）：

* 比如现在我们希望用户在 input 中输入一个问题；

* 每当用户输入了最新的内容，我们就获取到最新的内容，并且使用该问题去服务器查询答案；

* 那么，我们就需要实时的去获取最新的数据变化；

　　![image.png](image-20211129135628-lf5yedp.png)

　　![image.png](image-20211129135620-t0trhde.png)

　　

## 侦听器 watch 的配置选项

　　我们先来看一个例子：

* 当我们点击按钮的时候会**修改 info.name** 的值；

* 这个时候我们使用 **watch 来侦听 info，可以侦听到吗？**答案是**不可以**。

　　这是因为默认情况下，**watch 只是在侦听 info 的引用变化**，对于**内部属性的变化是不会做出响应**的：

* 这个时候我们可以使用一个**选项 deep** 进行更深层的侦听；

* 注意前面我们说过 watch 里面侦听的属性对应的也可以是一个 Object；

　　还有**另外一个属性**，是**希望一开始的就会立即执行一次**：

* 这个时候我们使用 **immediate 选项**；

* 这个时候无论后面数据是否有变化，侦听的函数都会有限执行一次；

　　

### 侦听器 watch 的配置选项（代码）

　　![image.png](image-20211129135649-72csuzc.png)

　　

## 侦听器 watch 的其他方式

#### （一）

　　![image.png](image-20211129135657-hdiw7jw.png)

#### （二）

　　另外一个是 Vue3 文档中没有提到的，但是 Vue2 文档中有提到的是侦听对象的属性：

　　![image.png](image-20211129135710-crqrx2j.png)

#### （三）

　　还有另外一种方式就是使用 $watch 的 API：

　　我们可以在 created 的生命周期（后续会讲到）中，使用 this.$watchs 来侦听；

* 第一个参数是要侦听的源；

* 第二个参数是侦听的回调函数 callback；

* 第三个参数是额外的其他选项，比如 deep、immediate；

　　![image.png](image-20211129135719-hi54qmn.png)

　　

# v-model

## v-model 的基本使用

　　**表单提交**是开发中非常常见的功能，也是和用户交互的重要手段：

* 比如用户在**登录、注册**时需要提交账号密码；

* 比如用户在**检索、创建、更新**信息时，需要提交一些数据；

　　这些都要求我们可以在**代码逻辑中获取到用户提交的数据**，我们通常会使用 **v-model 指令**来完成：

* **v-model 指令**可以在表单 input、textarea 以及 select 元素上创建**双向数据绑定**；

* 它会根据**控件类型**自动选取正确的方法来更新元素；

* 尽管有些神奇，**但 v-model 本质上不过是语法糖**，它**负责监听用户的输入事件来更新数据**，并在某种极端场景下进行一些特殊处理；

　　![image.png](image-20211129135726-d5bo9yj.png)

　　

## v-model 的原理

　　官方有说到，**v-model 的原理**其实是背后有两个操作：

* v-bind 绑定 value 属性的值；

* v-on 绑定 input 事件监听到函数中，函数会获取最新的值赋值到绑定的属性中；

　　![image.png](image-20211129135732-0v5eotn.png)

　　

### 事实上 v-model 更加复杂（源码）

　　![image.png](image-20211115103629-3r5viiy.png)

　　

## v-model 绑定 textarea

　　我们再来绑定一下其他的表单类型：textarea、checkbox、radio、select

　　	我们来看一下绑定 textarea：

　　![image.png](image-20211129142313-50otrb8.png)

　　

## v-model 绑定 checkbox

　　我们来看一下 v-model 绑定 **checkbox**：单个勾选框和多个勾选框

　　**单个勾选框：**

* v-model 即为布尔值。

* 此时 input 的 value 并不影响 v-model 的值。

　　**多个复选框：**

* 当是多个复选框时，因为可以选中多个，所以对应的 data 中属性是一个数组。

* 当选中某一个时，就会将 input 的 value 添加到数组中。

　　![image.png](image-20211129142328-gp2vonj.png)

　　![image.png](image-20211129142333-ioviz3a.png)

　　

## v-model 绑定 radio

　　v-model 绑定 radio，用于选择其中一项；

　　![image.png](image-20211129142339-7tchh53.png)

　　

## v-model 绑定 select

　　**和 checkbox 一样，select 也分单选和多选两种情况。**

　　**单选：只能选中一个值**

* v-model 绑定的是一个值；

* 当我们选中 option 中的一个时，会将它对应的 value 赋值到 fruit 中；

　　**多选：可以选中多个值**

* v-model 绑定的是一个数组；

* 当选中多个值时，就会将选中的 option 对应的 value 添加到数组 fruit 中；

　　![image.png](image-20211129142353-zgn9upz.png)

　　![image.png](image-20211129142359-gbo1iwo.png)

　　

## v-model 的值绑定

　　目前我们在前面的案例中**大部分的值**都是在 **template 中固定****好的**：

* 比如 gender 的两个输入框值 male、female；

* 比如 hobbies 的三个输入框值 basketball、football、tennis；

　　在真实开发中，我们的**数据可能是来自服务器**的，那么我们就可以先**将值请求下来，绑定到 data 返回的对象中**，再通过 **v-bind 来进行值的绑定**，这个过程就是**值绑定**。

* 这里不再给出具体的做法，因为还是 v-bind 的使用过程。

　　

## v-model 修饰符 - lazy

　　lazy 修饰符是什么作用呢？

* 默认情况下，v-model 在进行双向绑定时，绑定的是 **input 事件**，那么会在每次内容输入后就将最新的值和绑定的属性进行同步；

* 如果我们在 v-model 后跟上 lazy 修饰符，那么会将绑定的事件切换为 **change 事件**，只有在提交时（比如回车）才会触发；

　　![image.png](image-20211129142407-dvyv15q.png)

　　

## v-model 修饰符 - number

　　我们先来看一下 v-model 绑定后的值是什么类型的：

* message 总是 **string 类型**，即使在我们**设置 type 为 number 也是 string 类型**；
* ![image.png](image-20211115104632-9p772e9.png)

　　如果我们希望转换为**数字类型**，那么可以使用 **.number 修饰符**：

　　![image.png](image-20211129142418-wnpvxym.png)

　　另外，在我们进行**逻辑判断**时，如果是一个 **string 类型**，在可以转化的情况下**会进行隐式转换**的：

* 下面的 score 在进行判断的过程中会进行隐式转化的；
* ![image.png](image-20211129142423-vshxqr9.png)

　　

## v-model 修饰符 - trim

　　如果要自动过滤用户输入的守卫空白字符（去除空格），可以给 v-model 添加 **trim 修饰符**：

　　![image.png](image-20211129142430-b0cjiui.png)

　　

## v-mode 组件上使用

　　v-model 也可以使用在组件上，Vue2 版本和 Vue3 版本有一些区别。

　　具体的使用方法，后面讲组件化开发再具体学习。

　　
